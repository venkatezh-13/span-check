<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SPAN Comparator</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-primary: #0a0b0f;
      --bg-secondary: #111318;
      --bg-card: rgba(17, 19, 24, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-highlight: rgba(255, 255, 255, 0.05);
      
      --neon-cyan: #00f0ff;
      --neon-blue: #0066ff;
      --neon-purple: #bf00ff;
      --neon-green: #00ff88;
      --neon-red: #ff3366;
      --neon-orange: #ffaa00;
      
      --text-primary: #ffffff;
      --text-secondary: #8b92a8;
      --text-muted: #5a6275;
      
      --font-mono: 'JetBrains Mono', monospace;
      --font-sans: 'Inter', sans-serif;
      
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Animated background grid */
    .bg-grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(0, 240, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 240, 255, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 0;
    }

    .bg-glow {
      position: fixed;
      width: 600px;
      height: 600px;
      border-radius: 50%;
      filter: blur(150px);
      opacity: 0.15;
      pointer-events: none;
      z-index: 0;
    }

    .glow-1 { top: -200px; left: -200px; background: var(--neon-cyan); }
    .glow-2 { bottom: -200px; right: -200px; background: var(--neon-purple); }

    /* Glassmorphism card base */
    .glass {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.37),
        inset 0 1px 0 var(--glass-highlight);
    }

    /* Header */
    header {
      position: sticky;
      top: 0;
      z-index: 100;
      border-bottom: 1px solid var(--glass-border);
      background: rgba(10, 11, 15, 0.8);
      backdrop-filter: blur(20px);
    }

    .header-content {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
    }

    .brand-text h1 {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.5px;
      background: linear-gradient(to right, var(--text-primary), var(--neon-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .brand-text p {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--glass-border);
    }

    .control-group label {
      font-size: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }

    select {
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      outline: none;
    }

    select option {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    /* Main Layout */
    main {
      position: relative;
      z-index: 1;
      max-width: 1600px;
      margin: 0 auto;
      padding: 32px;
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 24px;
    }

    @media (max-width: 1200px) {
      main { grid-template-columns: 1fr; }
    }

    /* Cards */
    .card {
      border-radius: var(--radius-xl);
      padding: 24px;
      transition: all 0.3s ease;
    }

    .card:hover {
      border-color: rgba(0, 240, 255, 0.2);
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.5),
        0 0 0 1px rgba(0, 240, 255, 0.1);
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .card-title {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card-title::before {
      content: '';
      width: 4px;
      height: 16px;
      background: var(--neon-cyan);
      border-radius: 2px;
    }

    .badge {
      padding: 6px 12px;
      border-radius: var(--radius-lg);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: var(--font-mono);
    }

    .badge-idle { background: rgba(90, 98, 117, 0.2); color: var(--text-muted); border: 1px solid rgba(90, 98, 117, 0.3); }
    .badge-loading { background: rgba(0, 102, 255, 0.2); color: var(--neon-blue); border: 1px solid rgba(0, 102, 255, 0.3); animation: pulse 2s infinite; }
    .badge-success { background: rgba(0, 255, 136, 0.15); color: var(--neon-green); border: 1px solid rgba(0, 255, 136, 0.3); }
    .badge-error { background: rgba(255, 51, 102, 0.15); color: var(--neon-red); border: 1px solid rgba(255, 51, 102, 0.3); }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* File Upload Zone */
    .upload-zone {
      border: 2px dashed var(--glass-border);
      border-radius: var(--radius-lg);
      padding: 32px;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .upload-zone::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.1), transparent);
      transition: left 0.5s;
    }

    .upload-zone:hover::before {
      left: 100%;
    }

    .upload-zone:hover, .upload-zone.active {
      border-color: var(--neon-cyan);
      background: rgba(0, 240, 255, 0.05);
    }

    .upload-zone.has-file {
      border-color: var(--neon-green);
      background: rgba(0, 255, 136, 0.05);
    }

    .upload-icon {
      font-size: 32px;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .upload-zone:hover .upload-icon, .upload-zone.active .upload-icon {
      color: var(--neon-cyan);
    }

    .upload-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .upload-hint {
      font-size: 12px;
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    .file-input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    /* Form Elements */
    .form-stack {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .field-hint {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    select.field-input, input.field-input {
      width: 100%;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.2s;
    }

    select.field-input:focus, input.field-input:focus {
      outline: none;
      border-color: var(--neon-cyan);
      box-shadow: 0 0 0 3px rgba(0, 240, 255, 0.1);
    }

    /* Buttons */
    .btn {
      padding: 12px 24px;
      border-radius: var(--radius-md);
      border: none;
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
      color: var(--bg-primary);
      box-shadow: 0 4px 20px rgba(0, 240, 255, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 30px rgba(0, 240, 255, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      border: 1px solid var(--glass-border);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--neon-cyan);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn-group {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    /* Progress Bar */
    .progress-container {
      margin-top: 16px;
    }

    .progress-bar {
      height: 4px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-cyan), var(--neon-blue));
      border-radius: 2px;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    .progress-text {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 6px;
      font-family: var(--font-mono);
      display: flex;
      justify-content: space-between;
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin: 16px 0;
    }

    .stat-box {
      padding: 16px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: var(--radius-md);
      border: 1px solid var(--glass-border);
    }

    .stat-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 700;
      font-family: var(--font-mono);
      color: var(--text-primary);
    }

    .stat-value.positive { color: var(--neon-green); }
    .stat-value.negative { color: var(--neon-red); }

    /* Filters */
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    /* Table */
    .table-container {
      border-radius: var(--radius-lg);
      overflow: hidden;
      border: 1px solid var(--glass-border);
      max-height: 70vh;
      overflow: auto;
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 13px;
    }

    thead {
      position: sticky;
      top: 0;
      z-index: 10;
    }

    th {
      background: rgba(17, 19, 24, 0.95);
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      border-bottom: 1px solid var(--glass-border);
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      transition: all 0.2s;
    }

    th:hover {
      color: var(--neon-cyan);
      background: rgba(0, 240, 255, 0.05);
    }

    th.num { text-align: right; }
    th .sort-arrow {
      margin-left: 6px;
      opacity: 0.5;
      font-size: 10px;
    }

    th.active-sort {
      color: var(--neon-cyan);
    }

    th.active-sort .sort-arrow {
      opacity: 1;
    }

    td {
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      font-family: var(--font-mono);
      white-space: nowrap;
    }

    td.num { text-align: right; font-variant-numeric: tabular-nums; }

    tr:hover td {
      background: rgba(0, 240, 255, 0.03);
    }

    .tag {
      display: inline-flex;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      font-family: var(--font-sans);
    }

    .tag-fut { background: rgba(0, 102, 255, 0.2); color: var(--neon-blue); }
    .tag-ce { background: rgba(0, 255, 136, 0.15); color: var(--neon-green); }
    .tag-pe { background: rgba(255, 51, 102, 0.15); color: var(--neon-red); }

    .diff-positive { color: var(--neon-red); }
    .diff-negative { color: var(--neon-green); }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--glass-border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 240, 255, 0.3);
    }

    /* Links */
    .links-list {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--glass-border);
    }

    .links-list a {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 13px;
      transition: all 0.2s;
    }

    .links-list a:hover {
      color: var(--neon-cyan);
      transform: translateX(4px);
    }

    .links-list a::after {
      content: '‚Üí';
      margin-left: auto;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .links-list a:hover::after {
      opacity: 1;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }

    .empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    /* Compact mode */
    body.compact .card { padding: 16px; }
    body.compact td, body.compact th { padding: 8px 12px; }
    body.compact .table-container { max-height: 80vh; }

    /* Animations */
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .animate-in {
      animation: slideIn 0.4s ease forwards;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header-content { flex-direction: column; align-items: flex-start; }
      main { padding: 16px; }
      .filters-grid { grid-template-columns: 1fr; }
      .stats-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="bg-grid"></div>
<div class="bg-glow glow-1"></div>
<div class="bg-glow glow-2"></div>

<header>
  <div class="header-content">
    <div class="brand">
      <div class="logo">SP</div>
      <div class="brand-text">
        <h1>SPAN Comparator</h1>
        <p>Intraday vs BOD Margin Analysis</p>
      </div>
    </div>
    
    <div class="header-controls">
      <div class="control-group">
        <label>Theme</label>
        <select id="theme_mode">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
        </select>
      </div>
      <div class="control-group">
        <label>Accent</label>
        <select id="accent">
          <option value="cyan" selected>Cyan</option>
          <option value="purple">Purple</option>
          <option value="green">Green</option>
          <option value="orange">Orange</option>
        </select>
      </div>
      <div class="control-group">
        <label>Compact</label>
        <input type="checkbox" id="compact" style="accent-color: var(--neon-cyan);">
      </div>
    </div>
  </div>
</header>

<main>
  <!-- LEFT PANEL -->
  <section class="glass card animate-in">
    <div class="card-header">
      <div class="card-title">Data Sources</div>
      <span class="badge badge-idle" id="status_badge">IDLE</span>
    </div>

    <div class="form-stack">
      <!-- Segment -->
      <div class="field">
        <label class="field-label">Market Segment</label>
        <select id="segment" class="field-input">
          <option value="NFO" selected>NFO (NSE F&O)</option>
          <option value="BFO">BFO (BSE F&O)</option>
          <option value="MCX">MCX Commodities</option>
        </select>
      </div>

      <!-- Intraday Upload -->
      <div class="field">
        <label class="field-label">Intraday SPAN</label>
        <div class="upload-zone" id="zone_intra">
          <input type="file" id="intra" class="file-input" accept=".spn,.xml,.zip">
          <div class="upload-icon">üìä</div>
          <div class="upload-text">Drop SPAN file here</div>
          <div class="upload-hint">.spn, .xml, or .zip</div>
        </div>
      </div>

      <!-- BOD Upload -->
      <div class="field">
        <label class="field-label">BOD SPAN</label>
        <div class="upload-zone" id="zone_bod">
          <input type="file" id="bod" class="file-input" accept=".spn,.xml,.zip">
          <div class="upload-icon">üìà</div>
          <div class="upload-text">Drop BOD file here</div>
          <div class="upload-hint">.spn, .xml, or .zip</div>
        </div>
      </div>

      <!-- Bhav Upload -->
      <div class="field" id="bhav_field">
        <label class="field-label">Bhavcopy (Lots)</label>
        <div class="upload-zone" id="zone_bhav">
          <input type="file" id="bhav" class="file-input">
          <div class="upload-icon">üìã</div>
          <div class="upload-text">Optional: Bhav for lot sizes</div>
          <div class="upload-hint" id="bhav_hint">CSV/ZIP for NFO, XLS for MCX</div>
        </div>
        <div class="field-hint" id="lot_status">Using default lot sizes</div>
      </div>

      <!-- Filter Checkbox -->
      <label id="bhav_filter_wrap" style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 8px;">
        <input type="checkbox" id="bhav_filter" checked style="accent-color: var(--neon-cyan);">
        <span style="font-size: 13px; color: var(--text-secondary);">Filter by Bhav expiry dates</span>
      </label>

      <!-- Alert for BFO -->
      <div id="bfo_hint" style="display: none; padding: 12px; background: rgba(255, 170, 0, 0.1); border: 1px solid rgba(255, 170, 0, 0.3); border-radius: 8px; font-size: 13px; color: var(--neon-orange);">
        ‚ö†Ô∏è BFO: Using hardcoded lots (SENSEX=20, BANKEX=30, SENSEX50=75)
      </div>

      <!-- Progress -->
      <div class="progress-container" id="progress_container" style="display: none;">
        <div class="progress-bar">
          <div class="progress-fill" id="prog" style="width: 0%"></div>
        </div>
        <div class="progress-text">
          <span id="meta">Ready to process</span>
          <span id="prog_percent">0%</span>
        </div>
      </div>

      <!-- Stats -->
      <div class="stats-grid" id="stats_grid" style="display: none;">
        <div class="stat-box">
          <div class="stat-label">Contracts</div>
          <div class="stat-value" id="stat_count">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Matched</div>
          <div class="stat-value" id="stat_matched">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Intraday Total</div>
          <div class="stat-value" id="stat_intra">‚Çπ0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">BOD Total</div>
          <div class="stat-value" id="stat_bod">‚Çπ0</div>
        </div>
      </div>

      <!-- Actions -->
      <div class="btn-group">
        <button id="btn_export" class="btn btn-secondary" disabled>Export CSV</button>
        <button id="btn_clear" class="btn btn-secondary">Clear</button>
      </div>

      <!-- Links -->
      <div class="links-list">
        <a href="https://www.nseindia.com/all-reports-derivatives" target="_blank">NSE Reports</a>
        <a href="https://www.bseindia.com/markets/MarketInfo/BhavCopy.aspx" target="_blank">BSE Bhavcopy</a>
        <a href="https://www.mcxindia.com/education-training/daily-span-risk-parameter-file" target="_blank">MCX SPAN</a>
      </div>
    </div>
  </section>

  <!-- RIGHT PANEL -->
  <section class="glass card animate-in" style="animation-delay: 0.1s;">
    <div class="card-header">
      <div class="card-title">Analysis Results</div>
      <span class="badge badge-idle" id="count_badge">0 ROWS</span>
    </div>

    <!-- Filters -->
    <div class="filters-grid">
      <div class="field">
        <label class="field-label">Instrument</label>
        <select id="f_type" class="field-input">
          <option value="FUT" selected>Futures</option>
          <option value="CE">Call Options</option>
          <option value="PE">Put Options</option>
          <option value="ALL">All Instruments</option>
        </select>
      </div>
      
      <div class="field">
        <label class="field-label">Year</label>
        <select id="f_year" class="field-input">
          <option value="ALL">All Years</option>
        </select>
      </div>
      
      <div class="field">
        <label class="field-label">Month</label>
        <select id="f_month" class="field-input">
          <option value="ALL">All Months</option>
        </select>
      </div>
      
      <div class="field">
        <label class="field-label">Symbol</label>
        <input type="text" id="f_symbol" class="field-input" placeholder="NIFTY, CRUDEOIL...">
      </div>
      
      <div class="field" id="strike_field" style="display: none;">
        <label class="field-label">Strike</label>
        <input type="text" id="f_strike" class="field-input" placeholder="e.g. 25000">
      </div>
      
      <div class="field">
        <label class="field-label">Sort By</label>
        <select id="sort_key" class="field-input">
          <option value="symbol" selected>Symbol</option>
          <option value="expiry">Expiry</option>
          <option value="intraday">Intraday</option>
          <option value="BOD">BOD</option>
          <option value="diff">Difference</option>
          <option value="pct">% Change</option>
        </select>
      </div>
      
      <div class="field">
        <label class="field-label">Order</label>
        <select id="sort_dir" class="field-input">
          <option value="asc">Ascending</option>
          <option value="desc" selected>Descending</option>
        </select>
      </div>
    </div>

    <!-- Table -->
    <div class="table-container">
      <table>
        <thead>
          <tr id="thead_row">
            <th>Upload files to begin analysis</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr>
            <td colspan="10" class="empty-state">
              <div class="empty-icon">üìÇ</div>
              <div>Drop SPAN files in the left panel to start</div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <div style="margin-top: 12px; font-size: 12px; color: var(--text-muted); display: flex; justify-content: space-between; align-items: center;">
      <span id="render_note">Ready for data</span>
      <span style="font-family: var(--font-mono);">LIMIT: 6,000 rows</span>
    </div>
  </section>
</main>

<script>
/** Storage helpers **/
const LS = {
  get: (k, d=null) => { try { const v = localStorage.getItem(k); return v === null ? d : v; } catch { return d; } },
  set: (k, v) => { try { localStorage.setItem(k, v); } catch {} },
};

/** Accent presets */
const ACCENTS = {
  cyan:    { primary: "#00f0ff", secondary: "#0066ff" },
  purple:  { primary: "#bf00ff", secondary: "#ff00aa" },
  green:   { primary: "#00ff88", secondary: "#00cc66" },
  orange:  { primary: "#ffaa00", secondary: "#ff6600" }
};

function applyAccent(name){
  const a = ACCENTS[name] || ACCENTS.cyan;
  const root = document.documentElement;
  root.style.setProperty('--neon-cyan', a.primary);
  root.style.setProperty('--neon-blue', a.secondary);
  LS.set("ui.accent", name);
  $("accent").value = name;
}

function applyCompact(on){
  document.body.classList.toggle("compact", !!on);
  $("compact").checked = on;
  LS.set("ui.compact", on ? "1" : "0");
}

/** Lots */
const BFO_LOTS = { "SENSEX50": 75, "BANKEX": 30, "SENSEX": 20 };
const MCX_FALLBACK = {
  "ALUMINIUM": 5000, "ALUMINI": 1000, "CARDAMOM": 100, "COPPER": 2500,
  "CRUDEOIL": 100, "CRUDEOILM": 10, "ELECDMBL": 50, "ELECMBL": 50,
  "GOLD": 100, "GOLDGUINEA": 1, "GOLDM": 10, "GOLDTEN": 1, "GOLDPETAL": 1,
  "LEAD": 5000, "LEADMINI": 1000, "MCXBULLDEX": 30, "MENTHAOIL": 360,
  "NICKEL": 250, "NATURALGAS": 1250, "NATGASMINI": 250, "SILVER": 30,
  "SILVERM": 5, "SILVERMIC": 1, "ZINC": 5000, "ZINCMINI": 1000
};
const MCX_GRAM_QUOTE = { "GOLD":10, "GOLDM":10, "GOLDTEN":10, "GOLDPETAL":1, "GOLDGUINEA":8 };

const DISPLAY_LIMIT = 6000;
const MONTH_NAMES = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
const $ = (id) => document.getElementById(id);

const fmt = (x) => (x === null || x === undefined || Number.isNaN(x)) ? "‚Äî" : "‚Çπ" + (+x).toLocaleString('en-IN', {maximumFractionDigits: 2});
const fmtPct = (x) => (x === null || x === undefined || !Number.isFinite(x)) ? "‚Äî" : (x > 0 ? "+" : "") + x.toFixed(2) + "%";
const fmtDate = (exp) => {
  if (!exp || exp.length !== 8) return exp || "";
  const d = exp.slice(6,8), m = MONTH_NAMES[Number(exp.slice(4,6))-1], y = exp.slice(0,4);
  return `${d}-${m}-${y}`;
};

function setStatus(text, type="idle"){
  const b = $("status_badge");
  b.textContent = text.toUpperCase();
  b.className = "badge badge-" + type;
}
function setProg(p){ 
  $("prog").style.width = Math.max(0, Math.min(100, p)) + "%"; 
  $("prog_percent").textContent = Math.round(p) + "%";
  $("progress_container").style.display = p > 0 ? "block" : "none";
}
function setMeta(t){ $("meta").textContent = t || "Ready"; }

let LOT_SOURCE = "default";
let LOT_BY_SYMBOL = {};
let LOT_BY_KEY = {};
let BHAV_KEYS = new Set();
let LOT_MISSING = 0;
let FILTER_DROPPED = 0;

function resetLots(){
  LOT_SOURCE = "default";
  LOT_BY_SYMBOL = {};
  LOT_BY_KEY = {};
  BHAV_KEYS = new Set();
  LOT_MISSING = 0;
  FILTER_DROPPED = 0;
}
function setLotStatus(){
  const seg = $("segment").value;
  const el = $("lot_status");
  if (seg === "BFO"){
    el.textContent = "Using hardcoded BFO lots";
    el.style.color = "var(--neon-orange)";
    return;
  }
  if (LOT_SOURCE === "bhav"){
    const ns = Object.keys(LOT_BY_SYMBOL||{}).length;
    el.textContent = `Bhav loaded: ${ns} symbols`;
    el.style.color = "var(--neon-green)";
  } else {
    el.textContent = "Using default lot sizes (1)";
    el.style.color = "var(--text-muted)";
  }
}
function lotFor(seg, symbol, expiry){
  symbol = (symbol || "").toUpperCase();
  expiry = (expiry || "").trim();
  if (seg === "BFO") return BFO_LOTS[symbol] || 1;
  if (seg === "MCX"){
    if (LOT_SOURCE === "bhav" && LOT_BY_SYMBOL[symbol]) return LOT_BY_SYMBOL[symbol];
    return MCX_FALLBACK[symbol] || 1;
  }
  if (LOT_SOURCE === "bhav"){
    const k = symbol + "|" + expiry;
    if (LOT_BY_KEY[k]) return LOT_BY_KEY[k];
    if (LOT_BY_SYMBOL[symbol]) return LOT_BY_SYMBOL[symbol];
  }
  return 1;
}
function shouldKeepByBhav(seg, symbol, expiry){
  if (seg !== "NFO") return true;
  if (LOT_SOURCE !== "bhav") return true;
  if (!$("bhav_filter").checked) return true;
  return BHAV_KEYS.has(symbol.toUpperCase() + "|" + (expiry||"").trim());
}

/** ZIP helpers **/
function findEOCD(u8){
  const sig = 0x06054b50;
  const maxBack = Math.min(u8.length, 0xFFFF + 22);
  for (let i = u8.length - 22; i >= u8.length - maxBack; i--){
    if (i < 0) break;
    if ((u8[i] | (u8[i+1]<<8) | (u8[i+2]<<16) | (u8[i+3]<<24)) >>> 0 === sig) return i;
  }
  return -1;
}
async function unzipPickFirstMatching(file, predicate){
  const ab = await file.arrayBuffer();
  const u8 = new Uint8Array(ab);
  const dv = new DataView(ab);
  const eocdPos = findEOCD(u8);
  if (eocdPos === -1) throw new Error("ZIP: cannot find EOCD");
  const cdCount = dv.getUint16(eocdPos + 10, true);
  const cdOff = dv.getUint32(eocdPos + 16, true);
  let ptr = cdOff;
  const CD_SIG = 0x02014b50;
  let chosen = null;
  for (let i=0;i<cdCount;i++){
    if (dv.getUint32(ptr, true) !== CD_SIG) break;
    const compSize = dv.getUint32(ptr + 20, true);
    const fnameLen = dv.getUint16(ptr + 28, true);
    const extraLen = dv.getUint16(ptr + 30, true);
    const commLen = dv.getUint16(ptr + 32, true);
    const lho = dv.getUint32(ptr + 42, true);
    const nameBytes = u8.slice(ptr + 46, ptr + 46 + fnameLen);
    const name = new TextDecoder("utf-8").decode(nameBytes);
    if (!chosen && predicate(name)) { chosen = { name, compSize, lho }; break; }
    ptr = ptr + 46 + fnameLen + extraLen + commLen;
  }
  if (!chosen) throw new Error("ZIP: no matching file entry");
  const LFH_SIG = 0x04034b50;
  if (dv.getUint32(chosen.lho, true) !== LFH_SIG) throw new Error("ZIP: bad local header");
  const method = dv.getUint16(chosen.lho + 8, true);
  const fnameLen = dv.getUint16(chosen.lho + 26, true);
  const extraLen = dv.getUint16(chosen.lho + 28, true);
  const dataStart = chosen.lho + 30 + fnameLen + extraLen;
  const comp = u8.slice(dataStart, dataStart + chosen.compSize);
  if (method === 0) return new TextDecoder("utf-8").decode(comp);
  if (method !== 8) throw new Error("ZIP: unsupported compression");
  for (const fmt of ["deflate-raw","deflate"]){
    try{
      const ds = new DecompressionStream(fmt);
      const stream = new Blob([comp]).stream().pipeThrough(ds);
      const outAb = await new Response(stream).arrayBuffer();
      return new TextDecoder("utf-8").decode(new Uint8Array(outAb));
    }catch(e){}
  }
  throw new Error("ZIP: unable to inflate");
}
async function readTextMaybeZip(file, wantedExts){
  const name = (file.name || "").toLowerCase();
  if (name.endsWith(".zip")){
    return await unzipPickFirstMatching(file, (n) => wantedExts.some(ext => n.toLowerCase().endsWith(ext)));
  }
  return await file.text();
}

/** Worker parser **/
function makeWorker(){
  const workerSrc = `
  function indexOfTagOpen(text, tag, from){ return text.indexOf('<' + tag, from); }
  function blockInner(text, tag, from){
    const start = indexOfTagOpen(text, tag, from);
    if (start === -1) return null;
    const openEnd = text.indexOf('>', start);
    if (openEnd === -1) return null;
    const closeTag = '</' + tag + '>';
    const end = text.indexOf(closeTag, openEnd);
    if (end === -1) return null;
    return { inner: text.slice(openEnd + 1, end), start, end: end + closeTag.length };
  }
  function tagValue(text, tag){
    const open = '<' + tag + '>';
    const i = text.indexOf(open);
    if (i === -1) return '';
    const j = text.indexOf('</' + tag + '>', i + open.length);
    if (j === -1) return '';
    return text.slice(i + open.length, j).trim();
  }
  function minMaxAInRa(raText){
    let min = null, max = null, pos = 0;
    while (true){
      const aStart = raText.indexOf('<a', pos);
      if (aStart === -1) break;
      const aOpenEnd = raText.indexOf('>', aStart);
      if (aOpenEnd === -1) break;
      const aEnd = raText.indexOf('</a>', aOpenEnd);
      if (aEnd === -1) break;
      const valStr = raText.slice(aOpenEnd + 1, aEnd).trim();
      const n = Number(valStr);
      if (Number.isFinite(n)){
        min = (min === null) ? n : (n < min ? n : min);
        max = (max === null) ? n : (n > max ? n : max);
      }
      pos = aEnd + 4;
    }
    return {min, max};
  }
  function spanWorst(raText){
    const mm = minMaxAInRa(raText);
    if (mm.min === null || mm.max === null) return null;
    const a = Math.abs(mm.min), b = Math.abs(mm.max);
    return (a > b) ? a : b;
  }
  function parseFutures(xml){
    const out = [];
    let pos = 0;
    while (true){
      const pf = blockInner(xml, 'futPf', pos);
      if (!pf) break;
      pos = pf.end;
      const symbol = tagValue(pf.inner, 'pfCode').toUpperCase();
      if (!symbol) continue;
      let fpos = 0;
      while (true){
        const fut = blockInner(pf.inner, 'fut', fpos);
        if (!fut) break;
        fpos = fut.end;
        const pe = tagValue(fut.inner, 'pe');
        const ra = blockInner(fut.inner, 'ra', 0);
        const span = ra ? spanWorst(ra.inner) : null;
        out.push({ symbol, expiry: pe, type:'FUT', optCp:'', strike:'', span });
      }
    }
    return out;
  }
  function parseOptions(xml){
    const out = [];
    const tags = ['oopPf','oofPf'];
    for (const tag of tags){
      let pos = 0;
      while (true){
        const cont = blockInner(xml, tag, pos);
        if (!cont) break;
        pos = cont.end;
        const und = blockInner(cont.inner, 'undPf', 0);
        const symbol = und ? tagValue(und.inner, 'pfCode').toUpperCase() : tagValue(cont.inner, 'pfCode').toUpperCase();
        if (!symbol) continue;
        let spos = 0;
        while (true){
          const series = blockInner(cont.inner, 'series', spos);
          if (!series) break;
          spos = series.end;
          const pe = tagValue(series.inner, 'pe');
          let opos = 0;
          while (true){
            const opt = blockInner(series.inner, 'opt', opos);
            if (!opt) break;
            opos = opt.end;
            const o = tagValue(opt.inner, 'o');
            const optCp = (o === 'C') ? 'CE' : (o === 'P') ? 'PE' : '';
            const strike = tagValue(opt.inner, 'k');
            const prem = tagValue(opt.inner, 'p');
            const ra = blockInner(opt.inner, 'ra', 0);
            const span = ra ? spanWorst(ra.inner) : null;
            out.push({ symbol, expiry: pe, type:'OPT', optCp, strike, span, prem });
          }
        }
      }
    }
    return out;
  }
  function parseByExchange(xmlText, targetExch){
    const found = [];
    let rows = [], futCount = 0, optCount = 0, pos = 0;
    let anyExchangeBlocks = false;
    while (true){
      const ex = blockInner(xmlText, 'exchange', pos);
      if (!ex) break;
      anyExchangeBlocks = true;
      pos = ex.end;
      const code = tagValue(ex.inner, 'exch').toUpperCase();
      if (code && found.indexOf(code) === -1) found.push(code);
      if (code && code === targetExch){
        const futRows = parseFutures(ex.inner);
        const optRows = parseOptions(ex.inner);
        futCount += futRows.length; optCount += optRows.length;
        rows = rows.concat(futRows, optRows);
      }
    }
    if (anyExchangeBlocks){
      const matched = rows.length > 0;
      return { rows, meta:{ fut:futCount, opt:optCount, exchFound:found, exchUsed:targetExch, exchMatched: matched } };
    }
    const futRows = parseFutures(xmlText);
    const optRows = parseOptions(xmlText);
    return { rows: futRows.concat(optRows), meta:{ fut:futRows.length, opt:optRows.length, exchFound:[], exchUsed:targetExch, exchMatched:null } };
  }
  self.onmessage = (e) => {
    const { id, xmlText, targetExch } = e.data;
    try{
      const res = parseByExchange(xmlText, (targetExch || '').toUpperCase());
      self.postMessage({ id, ok:true, rows: res.rows || [], meta: res.meta || {} });
    }catch(err){
      self.postMessage({ id, ok:false, error: String(err?.message || err) });
    }
  };
  `;
  const blob = new Blob([workerSrc], {type:"application/javascript"});
  return new Worker(URL.createObjectURL(blob));
}
async function parseSpanText(xmlText, targetExch, worker, jobId){
  worker.postMessage({ id: jobId, xmlText, targetExch });
  return new Promise((resolve, reject) => {
    const handler = (e) => {
      if (e.data.id !== jobId) return;
      worker.removeEventListener("message", handler);
      if (!e.data.ok) reject(new Error(e.data.error || "parse failed"));
      else resolve({ rows: e.data.rows || [], meta: e.data.meta || {} });
    };
    worker.addEventListener("message", handler);
  });
}

/** Bhav parsing **/
function splitCsvLine(line){
  const out = [];
  let cur = "", inQ = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (inQ){
      if (ch === '"'){
        if (i+1 < line.length && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = false;
      } else cur += ch;
    } else {
      if (ch === '"') inQ = true;
      else if (ch === ','){ out.push(cur); cur=""; }
      else cur += ch;
    }
  }
  out.push(cur);
  return out;
}
function ymdFromBhavDate(s){
  const t = (s||"").trim();
  if (/^\d{4}-\d{2}-\d{2}$/.test(t)) return t.replaceAll("-","");
  if (/^\d{8}$/.test(t)) return t;
  return "";
}
async function loadLotsFromNseFoBhav(file){
  const text = await readTextMaybeZip(file, [".csv"]);
  const lines = text.split(/\r?\n/);
  if (lines.length < 2) throw new Error("Bhav: empty file");
  const header = splitCsvLine(lines[0]).map(s => s.trim());
  const idxSym = header.indexOf("TckrSymb");
  const idxLot = header.indexOf("NewBrdLotQty");
  const idxXpry = header.indexOf("XpryDt");
  if (idxSym === -1 || idxLot === -1) throw new Error("Bhav: need TckrSymb, NewBrdLotQty");
  if (idxXpry === -1) throw new Error("Bhav: need XpryDt for NFO expiry filter");

  const bySym = {};
  const byKey = {};
  const keys = new Set();
  for (let i=1;i<lines.length;i++){
    const line = lines[i];
    if (!line) continue;
    const cols = splitCsvLine(line);
    const sym = (cols[idxSym] || "").trim().toUpperCase();
    const lot = Number((cols[idxLot] || "").trim());
    const xpry = ymdFromBhavDate(cols[idxXpry] || "");
    if (!sym || !Number.isFinite(lot) || lot <= 0) continue;

    bySym[sym] = bySym[sym] ? Math.max(bySym[sym], lot) : lot;
    if (xpry){
      const k = sym + "|" + xpry;
      byKey[k] = byKey[k] ? Math.max(byKey[k], lot) : lot;
      keys.add(k);
    }
  }
  return { bySym, byKey, keys };
}
function parseNum(s){
  const m = String(s).match(/[-+]?\d*\.?\d+/);
  return m ? Number(m[0]) : null;
}
function parseUnit(s){
  const t = String(s).trim();
  const m = t.match(/[A-Za-z]+$/);
  return m ? m[0].toUpperCase() : "";
}
async function loadLotsFromMcxBhav(file){
  const text = await file.text();
  const parser = new DOMParser();
  const doc = parser.parseFromString(text, "text/html");
  const table = doc.querySelector("table");
  if (!table) throw new Error("MCX bhav: no table found");
  const rows = Array.from(table.querySelectorAll("tr"));
  if (rows.length < 2) throw new Error("MCX bhav: no rows");

  const headCells = Array.from(rows[0].querySelectorAll("th,td")).map(x => x.textContent.trim());
  const idxSymbol = headCells.findIndex(h => /symbol/i.test(h));
  const idxLots = headCells.findIndex(h => /Volume\(Lots\)/i.test(h));
  const idxVol = headCells.findIndex(h => /Volume\(In/i.test(h));
  if (idxSymbol === -1 || idxLots === -1 || idxVol === -1){
    throw new Error("MCX bhav: need columns Symbol, Volume(Lots), Volume(In 000's)");
  }

  const cand = {};
  for (let i=1;i<rows.length;i++){
    const cells = Array.from(rows[i].querySelectorAll("td"));
    if (cells.length < Math.max(idxSymbol, idxLots, idxVol) + 1) continue;
    const sym = (cells[idxSymbol].textContent || "").trim().toUpperCase();
    const vLots = parseNum(cells[idxLots].textContent);
    const v000 = parseNum(cells[idxVol].textContent);
    const unit = parseUnit(cells[idxVol].textContent);
    if (!sym || !vLots || !v000) continue;
    if (!(vLots > 0) || !(v000 > 0)) continue;

    let contractSize = (v000 * 1000) / vLots;
    if (!Number.isFinite(contractSize) || contractSize <= 0) continue;
    if (unit === "GRMS"){
      const q = MCX_GRAM_QUOTE[sym] || 1;
      contractSize = contractSize / q;
    }
    const mult = Math.round(contractSize);
    if (!cand[sym]) cand[sym] = [];
    if (cand[sym].length < 50) cand[sym].push(mult);
  }

  const bySym = {};
  for (const sym of Object.keys(cand)){
    const arr = cand[sym].slice().sort((a,b)=>a-b);
    const mid = Math.floor(arr.length/2);
    const median = (arr.length % 2) ? arr[mid] : Math.round((arr[mid-1] + arr[mid]) / 2);
    if (median > 0) bySym[sym] = median;
  }
  return { bySym };
}

/** Segment mapping **/
function targetExchForSegment(seg){
  if (seg === "NFO") return "NSE";
  if (seg === "BFO") return "BSE";
  if (seg === "MCX") return "MCX";
  return seg;
}

/** Data **/
let ALL_ROWS = [];
let META_LAST = { intra:null, bod:null };
let SORT = { key:"symbol", dir:"desc" };
let autoRunTimeout = null;

function yearMonthFromExpiry(exp){
  if (!exp || exp.length < 6) return {year:"", mon:""};
  const y = exp.slice(0,4);
  const m = exp.slice(4,6);
  const mi = Number(m) - 1;
  const mon = (mi>=0 && mi<12) ? MONTH_NAMES[mi] : m;
  return {year:y, mon};
}
function pctForRow(r){
  if (r.BOD !== null && r.BOD !== 0 && r.intraday !== null) return ((r.intraday - r.BOD) / r.BOD) * 100;
  return null;
}
function wantsOptColumns(){
  return $("f_type").value !== "FUT";
}
function currentFilters(){
  return {
    type: $("f_type").value,
    year: $("f_year").value,
    mon: $("f_month").value,
    symbol: $("f_symbol").value.trim().toUpperCase(),
    strike: $("f_strike").value.trim()
  };
}
function applyFilters(rows){
  const f = currentFilters();
  return rows.filter(r => {
    if (f.type !== "ALL"){
      if (f.type === "FUT" && r.type !== "FUT") return false;
      if (f.type === "CE" || f.type === "PE"){
        if (r.type !== "OPT") return false;
        if (r.optCp !== f.type) return false;
      }
    }
    if (f.year !== "ALL" && r.year !== f.year) return false;
    if (f.mon !== "ALL" && r.mon !== f.mon) return false;
    if (f.symbol && !r.symbol.includes(f.symbol)) return false;
    if (f.strike){
      const s = String(r.strike||"").replace(/\.0+$/,"");
      if (s !== f.strike) return false;
    }
    return true;
  });
}
function compare(a,b){
  const k = SORT.key;
  const dir = (SORT.dir === "desc") ? -1 : 1;
  const av = (k === "pct") ? pctForRow(a) : a[k];
  const bv = (k === "pct") ? pctForRow(b) : b[k];

  const numKeys = new Set(["intraday","BOD","diff","pct","strike"]);
  if (numKeys.has(k)){
    const an = (av === null || av === undefined || av === "") ? NaN : Number(av);
    const bn = (bv === null || bv === undefined || bv === "") ? NaN : Number(bv);
    if (Number.isNaN(an) && Number.isNaN(bn)) return 0;
    if (Number.isNaN(an)) return 1;
    if (Number.isNaN(bn)) return -1;
    return (an - bn) * dir;
  }
  const as = (av === null || av === undefined) ? "" : String(av);
  const bs = (bv === null || bv === undefined) ? "" : String(bv);
  return as.localeCompare(bs) * dir;
}
function sortRows(rows){
  const out = rows.slice();
  out.sort((a,b) => {
    const c = compare(a,b);
    if (c !== 0) return c;
    return (a.symbol+a.expiry+a.type+a.optCp+a.strike).localeCompare(b.symbol+b.expiry+b.type+b.optCp+b.strike);
  });
  return out;
}
function updateTableHeader(){
  const showOpt = wantsOptColumns();
  const tr = $("thead_row");
  tr.innerHTML = "";
  const cols = showOpt
    ? [
        {key:"symbol", label:"Symbol", cls:""},
        {key:"year", label:"Year", cls:""},
        {key:"mon", label:"Month", cls:""},
        {key:"expiry", label:"Expiry", cls:""},
        {key:"optCp", label:"Type", cls:""},
        {key:"strike", label:"Strike", cls:"num"},
        {key:"intraday", label:"Intraday", cls:"num"},
        {key:"BOD", label:"BOD", cls:"num"},
        {key:"diff", label:"Diff", cls:"num"},
        {key:"pct", label:"Change", cls:"num"}
      ]
    : [
        {key:"symbol", label:"Symbol", cls:""},
        {key:"year", label:"Year", cls:""},
        {key:"mon", label:"Month", cls:""},
        {key:"expiry", label:"Expiry", cls:""},
        {key:"intraday", label:"Intraday", cls:"num"},
        {key:"BOD", label:"BOD", cls:"num"},
        {key:"diff", label:"Diff", cls:"num"},
        {key:"pct", label:"Change", cls:"num"}
      ];

  for (const c of cols){
    const th = document.createElement("th");
    th.dataset.key = c.key;
    th.className = c.cls;
    if (SORT.key === c.key) th.classList.add("active-sort");
    th.innerHTML = c.label + (SORT.key === c.key ? `<span class="sort-arrow">${SORT.dir === "asc" ? "‚Üë" : "‚Üì"}</span>` : "");
    th.addEventListener("click", () => {
      if (SORT.key === c.key) SORT.dir = (SORT.dir === "asc") ? "desc" : "asc";
      else { SORT.key = c.key; SORT.dir = "desc"; }
      $("sort_key").value = SORT.key;
      $("sort_dir").value = SORT.dir;
      LS.set("ui.sortKey", SORT.key);
      LS.set("ui.sortDir", SORT.dir);
      render();
    });
    tr.appendChild(th);
  }
  $("strike_field").style.display = showOpt ? "block" : "none";
  if (!showOpt) $("f_strike").value = "";
}
function updateStats(filtered){
  $("stats_grid").style.display = "grid";
  let matched = 0, tIntra = 0, tBod = 0;
  for (const r of filtered){
    if (r.intraday !== null && r.BOD !== null){
      matched++;
      tIntra += r.intraday;
      tBod += r.BOD;
    }
  }
  $("stat_count").textContent = filtered.length.toLocaleString();
  $("stat_matched").textContent = matched.toLocaleString();
  $("stat_intra").textContent = "‚Çπ" + (tIntra/100000).toFixed(2) + "L";
  $("stat_bod").textContent = "‚Çπ" + (tBod/100000).toFixed(2) + "L";
  
  const diff = tIntra - tBod;
  $("stat_intra").className = "stat-value " + (diff > 0 ? "positive" : diff < 0 ? "negative" : "");
  $("stat_bod").className = "stat-value " + (diff < 0 ? "positive" : diff > 0 ? "negative" : "");
}
function render(){
  updateTableHeader();
  const filtered = applyFilters(ALL_ROWS);
  const sorted = sortRows(filtered);
  $("count_badge").textContent = sorted.length + " ROWS";
  updateStats(sorted);

  const rows = sorted.slice(0, DISPLAY_LIMIT);
  $("render_note").textContent = sorted.length > DISPLAY_LIMIT ? `Showing first ${DISPLAY_LIMIT.toLocaleString()} of ${sorted.length.toLocaleString()} rows` : `${sorted.length.toLocaleString()} rows`;

  const showOpt = wantsOptColumns();
  const tb = $("tbody");
  tb.innerHTML = "";

  if (rows.length === 0) {
    tb.innerHTML = `<tr><td colspan="10" class="empty-state"><div class="empty-icon">üîç</div><div>No matching contracts found</div></td></tr>`;
    $("btn_export").disabled = true;
    return;
  }

  for (const r of rows){
    const pct = pctForRow(r);
    const diffCls = (r.diff > 0) ? "diff-positive" : (r.diff < 0) ? "diff-negative" : "";
    const pctCls = (pct > 0) ? "diff-positive" : (pct < 0) ? "diff-negative" : "";
    
    const typeTag = r.type === 'FUT' ? '<span class="tag tag-fut">FUT</span>' : 
                   r.optCp === 'CE' ? '<span class="tag tag-ce">CE</span>' : 
                   r.optCp === 'PE' ? '<span class="tag tag-pe">PE</span>' : '';
    
    const tr = document.createElement("tr");
    if (showOpt){
      tr.innerHTML =
        `<td><strong>${r.symbol}</strong></td>` +
        `<td>${r.year}</td>` +
        `<td>${r.mon}</td>` +
        `<td>${fmtDate(r.expiry)}</td>` +
        `<td>${typeTag}</td>` +
        `<td class="num">${r.strike||""}</td>` +
        `<td class="num">${fmt(r.intraday)}</td>` +
        `<td class="num">${fmt(r.BOD)}</td>` +
        `<td class="num ${diffCls}">${r.diff !== null ? (r.diff > 0 ? "+" : "") + fmt(r.diff).replace("‚Çπ","") : "‚Äî"}</td>` +
        `<td class="num ${pctCls}">${fmtPct(pct)}</td>`;
    } else {
      tr.innerHTML =
        `<td><strong>${r.symbol}</strong></td>` +
        `<td>${r.year}</td>` +
        `<td>${r.mon}</td>` +
        `<td>${fmtDate(r.expiry)}</td>` +
        `<td class="num">${fmt(r.intraday)}</td>` +
        `<td class="num">${fmt(r.BOD)}</td>` +
        `<td class="num ${diffCls}">${r.diff !== null ? (r.diff > 0 ? "+" : "") + fmt(r.diff).replace("‚Çπ","") : "‚Äî"}</td>` +
        `<td class="num ${pctCls}">${fmtPct(pct)}</td>`;
    }
    tb.appendChild(tr);
  }
  $("btn_export").disabled = false;
}
function buildYearOptions(rows){
  const years = Array.from(new Set(rows.map(r => r.year).filter(Boolean))).sort();
  $("f_year").innerHTML = '<option value="ALL">All Years</option>' + years.map(y => `<option value="${y}">${y}</option>`).join("");
}
function buildMonthOptions(rows){
  const year = $("f_year").value || "ALL";
  const monthsSet = new Set();
  for (const r of rows){
    if (!r.mon) continue;
    if (year !== "ALL" && r.year !== year) continue;
    monthsSet.add(r.mon);
  }
  const months = Array.from(monthsSet).sort((a,b)=>MONTH_NAMES.indexOf(a)-MONTH_NAMES.indexOf(b));
  $("f_month").innerHTML = '<option value="ALL">All Months</option>' + months.map(m => `<option value="${m}">${m}</option>`).join("");
}
function toCSV(rows){
  const showOpt = wantsOptColumns();
  const seg = $("segment").value;
  const cols = showOpt
    ? ["segment","symbol","year","month","expiry","type","optCp","strike","intraday","BOD","diff","pct_chg"]
    : ["segment","symbol","year","month","expiry","type","intraday","BOD","diff","pct_chg"];

  const esc = (v) => {
    const s = (v===null || v===undefined) ? "" : String(v);
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
  };

  const out = [cols.join(",")];
  for (const r of rows){
    const diff = (r.intraday !== null && r.BOD !== null) ? (r.intraday - r.BOD) : null;
    const pct = pctForRow(r);
    const rec = {
      segment: seg,
      symbol: r.symbol, year: r.year, month: r.mon, expiry: fmtDate(r.expiry),
      type: r.type, optCp: r.optCp || "", strike: r.strike || "",
      intraday: r.intraday, BOD: r.BOD, diff, pct_chg: pct
    };
    out.push(cols.map(c => esc(rec[c])).join(","));
  }
  return out.join("\n");
}
function download(name, text){
  const blob = new Blob([text], {type:"text/csv;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

/** Lots load **/
async function loadLots(){
  const seg = $("segment").value;
  const fBhav = $("bhav").files[0];
  resetLots();

  if (seg === "BFO"){
    LOT_SOURCE = "hardcoded";
    setLotStatus();
    return;
  }
  if (!fBhav){
    LOT_SOURCE = "default";
    setLotStatus();
    return;
  }
  if (seg === "MCX"){
    const res = await loadLotsFromMcxBhav(fBhav);
    LOT_SOURCE = "bhav";
    LOT_BY_SYMBOL = res.bySym || {};
    setLotStatus();
    return;
  }
  const res = await loadLotsFromNseFoBhav(fBhav);
  LOT_SOURCE = "bhav";
  LOT_BY_SYMBOL = res.bySym || {};
  LOT_BY_KEY = res.byKey || {};
  BHAV_KEYS = res.keys || new Set();
  setLotStatus();
}
function computeLotMissing(rows){
  const seg = $("segment").value;
  if (seg === "BFO") return 0;
  if (LOT_SOURCE !== "bhav") return 0;
  let miss = 0;
  for (const r of rows){
    const sym = r.symbol;
    const exp = r.expiry;
    if (seg === "NFO"){
      const k = sym + "|" + exp;
      if (!LOT_BY_KEY[k] && !LOT_BY_SYMBOL[sym]) miss++;
    } else if (seg === "MCX"){
      if (!LOT_BY_SYMBOL[sym] && !MCX_FALLBACK[sym]) miss++;
    }
  }
  return miss;
}

/** Main parse **/
async function runParser(){
  const seg = $("segment").value;
  const targetExch = targetExchForSegment(seg);
  const fIntra = $("intra").files[0];
  const fBod = $("bod").files[0];

  if (!fIntra && !fBod){
    setStatus("Upload files", "idle");
    return;
  }

  let worker = null;
  try{
    setStatus("Processing", "loading");
    setProg(10);
    setMeta("Loading lot data...");
    await loadLots();

    setProg(30);
    setMeta("Reading SPAN files...");
    const intraText = fIntra ? await readTextMaybeZip(fIntra, [".spn",".xml"]) : null;
    const bodText = fBod ? await readTextMaybeZip(fBod, [".spn",".xml"]) : null;
    
    setProg(50);
    setMeta("Parsing XML...");
    worker = makeWorker();

    const chunks = [];
    META_LAST = { intra:null, bod:null };

    if (intraText){
      const res = await parseSpanText(intraText, targetExch, worker, "intra");
      chunks.push({ label:"intraday", rows: res.rows });
      META_LAST.intra = res.meta;
      setProg(70);
    }
    if (bodText){
      const res = await parseSpanText(bodText, targetExch, worker, "bod");
      chunks.push({ label:"BOD", rows: res.rows });
      META_LAST.bod = res.meta;
      setProg(90);
    }

    FILTER_DROPPED = 0;
    const byKey = new Map();
    const keyOf = (r) => [r.symbol, r.expiry, r.type, r.optCp||"", r.strike||""].join("|");

    for (const part of chunks){
      for (const r of part.rows){
        const symbol = (r.symbol || "").toUpperCase();
        const expiry = (r.expiry || "").trim();
        if (!symbol || !expiry) continue;
        if (!shouldKeepByBhav(seg, symbol, expiry)){
          FILTER_DROPPED++;
          continue;
        }
        const ym = yearMonthFromExpiry(expiry);
        const mult = lotFor(seg, symbol, expiry);
        const spanVal = (r.span === null || r.span === undefined) ? null : ((r.type === 'OPT' && r.prem !== undefined && r.prem !== null && r.prem !== '') ? ((r.span + Number(r.prem)) * mult) : (r.span * mult));

        const out = {
          symbol, expiry, year: ym.year, mon: ym.mon,
          type: r.type || "", optCp: r.optCp || "", strike: r.strike || "",
          intraday: null, BOD: null, diff: null
        };

        const k = keyOf(out);
        const existing = byKey.get(k) || out;
        if (part.label === "intraday") existing.intraday = spanVal;
        if (part.label === "BOD") existing.BOD = spanVal;
        byKey.set(k, existing);
      }
    }

    ALL_ROWS = Array.from(byKey.values()).map(r => {
      const diff = (r.intraday !== null && r.BOD !== null) ? (r.intraday - r.BOD) : null;
      return { ...r, diff };
    });

    LOT_MISSING = computeLotMissing(ALL_ROWS);
    setLotStatus();

    buildYearOptions(ALL_ROWS);
    const savedYear = LS.get("ui.year", "ALL");
    if ([...$("f_year").options].some(o => o.value === savedYear)) $("f_year").value = savedYear;
    buildMonthOptions(ALL_ROWS);
    const savedMon = LS.get("ui.mon", "ALL");
    if ([...$("f_month").options].some(o => o.value === savedMon)) $("f_month").value = savedMon;

    render();

    const found = (META_LAST.intra?.exchFound?.length) ? META_LAST.intra.exchFound : (META_LAST.bod?.exchFound?.length) ? META_LAST.bod.exchFound : [];
    const foundStr = found.length ? found.join(", ") : "‚Äî";
    const mi = META_LAST.intra ? `Intra: ${META_LAST.intra.fut||0}F/${META_LAST.intra.opt||0}O` : "";
    const mb = META_LAST.bod ? `BOD: ${META_LAST.bod.fut||0}F/${META_LAST.bod.opt||0}O` : "";

    const mismatch = (found.length > 0) && !((META_LAST.intra?.exchMatched) || (META_LAST.bod?.exchMatched));
    if (mismatch){
      setStatus("Exchange mismatch", "error");
      setMeta(`Found: ${foundStr} | Target: ${targetExch} not found`);
    } else {
      setStatus("Complete", "success");
      setMeta(`${foundStr} ‚Ä¢ ${mi} ${mb}`);
    }

    setProg(100);
    setTimeout(() => setProg(0), 1000);
  }catch(err){
    console.error(err);
    setStatus("Error", "error");
    setMeta(String(err?.message || err));
    setProg(0);
  }finally{
    if (worker) worker.terminate();
  }
}

/** Event handlers **/
function handleFileChange(type){
  const file = $(type).files[0];
  const zone = $(type === "intra" ? "zone_intra" : type === "bod" ? "zone_bod" : "zone_bhav");
  
  if (file){
    zone.classList.add("has-file");
    zone.querySelector(".upload-text").textContent = file.name;
    zone.querySelector(".upload-hint").textContent = (file.size/1024).toFixed(1) + " KB";
    
    // Auto-run on SPAN files
    if (type === "intra" || type === "bod"){
      clearTimeout(autoRunTimeout);
      autoRunTimeout = setTimeout(() => runParser(), 500);
    }
  } else {
    zone.classList.remove("has-file");
    zone.querySelector(".upload-text").textContent = type === "bhav" ? "Optional: Bhav for lot sizes" : "Drop SPAN file here";
    zone.querySelector(".upload-hint").textContent = type === "bhav" ? "CSV/ZIP for NFO, XLS for MCX" : ".spn, .xml, or .zip";
  }
}

$("intra").addEventListener("change", () => handleFileChange("intra"));
$("bod").addEventListener("change", () => handleFileChange("bod"));
$("bhav").addEventListener("change", () => handleFileChange("bhav"));

// Drag and drop
["intra","bod","bhav"].forEach(id => {
  const zone = $(id === "intra" ? "zone_intra" : id === "bod" ? "zone_bod" : "zone_bhav");
  zone.addEventListener("dragover", (e) => { e.preventDefault(); zone.classList.add("active"); });
  zone.addEventListener("dragleave", () => zone.classList.remove("active"));
  zone.addEventListener("drop", (e) => {
    e.preventDefault();
    zone.classList.remove("active");
    if (e.dataTransfer.files.length){
      $(id).files = e.dataTransfer.files;
      handleFileChange(id);
    }
  });
});

/** Segment UI **/
function configureSegmentUI(){
  const seg = $("segment").value;
  const bhav = $("bhav");
  const bhavHint = $("bhav_hint");
  const bhavFilterWrap = $("bhav_filter_wrap");
  const bfoHint = $("bfo_hint");

  if (seg === "NFO"){
    bhav.disabled = false;
    bhav.accept = ".csv,.zip";
    bhavHint.textContent = "CSV/ZIP with TckrSymb, NewBrdLotQty, XpryDt";
    bhavFilterWrap.style.display = "flex";
    bfoHint.style.display = "none";
  } else if (seg === "BFO"){
    bhav.disabled = true;
    bhav.value = "";
    handleFileChange("bhav");
    bhavHint.textContent = "Disabled for BFO";
    bhavFilterWrap.style.display = "none";
    bfoHint.style.display = "block";
    resetLots();
    LOT_SOURCE = "hardcoded";
    setLotStatus();
  } else {
    bhav.disabled = false;
    bhav.accept = ".xls,.html";
    bhavHint.textContent = "MCX bhav .xls (HTML table)";
    bhavFilterWrap.style.display = "none";
    bfoHint.style.display = "none";
  }

  ALL_ROWS = [];
  render();
  LS.set("ui.segment", seg);
}
$("segment").addEventListener("change", configureSegmentUI);

/** Export **/
$("btn_export").addEventListener("click", () => {
  const filtered = applyFilters(ALL_ROWS);
  const sorted = sortRows(filtered);
  const csv = toCSV(sorted);
  const seg = $("segment").value;
  const f = currentFilters();
  const stamp = new Date().toISOString().slice(0,10);
  const name = `SPAN_${seg}_${f.type}_${stamp}.csv`;
  download(name, csv);
});

/** Clear **/
$("btn_clear").addEventListener("click", () => {
  $("intra").value = ""; handleFileChange("intra");
  $("bod").value = ""; handleFileChange("bod");
  $("bhav").value = ""; handleFileChange("bhav");
  ALL_ROWS = [];
  resetLots();
  setLotStatus();
  $("stats_grid").style.display = "none";
  setMeta("Ready");
  setStatus("Idle", "idle");
  render();
});

/** Filters **/
$("f_year").addEventListener("change", () => { LS.set("ui.year",$("f_year").value); buildMonthOptions(ALL_ROWS); render(); });
$("f_month").addEventListener("change", () => { LS.set("ui.mon",$("f_month").value); render(); });
$("f_type").addEventListener("change", () => { LS.set("ui.type",$("f_type").value); render(); });
$("f_symbol").addEventListener("input", () => { LS.set("ui.symbol",$("f_symbol").value); render(); });
$("f_strike").addEventListener("input", () => { LS.set("ui.strike",$("f_strike").value); render(); });
$("sort_key").addEventListener("change", () => { SORT.key = $("sort_key").value; LS.set("ui.sortKey",SORT.key); render(); });
$("sort_dir").addEventListener("change", () => { SORT.dir = $("sort_dir").value; LS.set("ui.sortDir",SORT.dir); render(); });
$("bhav_filter").addEventListener("change", () => { 
  LS.set("ui.bhavFilter", $("bhav_filter").checked ? "1":"0"); 
  if (ALL_ROWS.length) runParser();
});

/** Theme **/
$("accent").addEventListener("change", () => applyAccent($("accent").value));
$("compact").addEventListener("change", () => applyCompact($("compact").checked));

/** Init **/
(function init(){
  applyAccent(LS.get("ui.accent", "cyan"));
  applyCompact(LS.get("ui.compact", "0") === "1");
  
  const seg = LS.get("ui.segment", "NFO");
  $("segment").value = seg;
  configureSegmentUI();

  $("f_type").value = LS.get("ui.type", "FUT");
  $("f_symbol").value = LS.get("ui.symbol", "");
  $("f_strike").value = LS.get("ui.strike", "");
  SORT.key = LS.get("ui.sortKey", "symbol");
  SORT.dir = LS.get("ui.sortDir", "desc");
  $("sort_key").value = SORT.key;
  $("sort_dir").value = SORT.dir;
  $("bhav_filter").checked = LS.get("ui.bhavFilter","1") === "1";

  updateTableHeader();
  render();
})();
</script>
</body>
</html>
